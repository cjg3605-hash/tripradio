# 팟캐스트 QA 테스트 계획 (페르소나 기반)

> **목적**: 팟캐스트 플로우를 실제 사용자 관점에서 검증
> **테스트 환경**: 로컬 개발 서버 (http://localhost:3000)
> **테스트 페르소나**: QA 테스터, 일반 사용자

---

## 🎭 테스트 페르소나

### 페르소나 1: QA 테스터 (자동화 테스트)
**목표**: 모든 플로우가 설계된 대로 동작하는가?

**테스트 관점**:
- ✅ API 응답 구조 검증
- ✅ 데이터 흐름 추적
- ✅ 오류 처리 확인
- ✅ 상태 전이 검증

### 페르소나 2: 일반 사용자 (수동 테스트)
**목표**: 자연스러운 사용자 경험인가?

**테스트 관점**:
- ✅ UI 반응성
- ✅ 명확한 피드백
- ✅ 오류 메시지 이해도
- ✅ 기능 완성도

---

## 📋 테스트 케이스 (총 8개)

### Test Case 1: 완성된 팟캐스트 접근
**시나리오**: 기존에 완성된 팟캐스트를 재방문

**페르소나**: 일반 사용자
**우선순위**: 🟢 높음 (일반적인 케이스)

```
1. 팟캐스트 페이지 접근
   URL: http://localhost:3000/ko/podcast/colosseum

2. 예상 동작:
   ✓ 페이지 로드
   ✓ "콜로세움" 제목 표시
   ✓ 오디오플레이어 표시
   ✓ 첫 세그먼트 정보 로드
   ✓ 챕터 목록 표시 (인트로 선택)

3. 검증 포인트:
   - GET /api/tts/notebooklm/generate?location=colosseum&language=ko 응답
   - status: 'completed'
   - segments: 모든 audio_url이 유효한 URL
   - chapters: 챕터 정보 완전함

4. 테스트 결과:
   [ ] 통과 / [ ] 실패 (사유: _______)
```

---

### Test Case 2: 새 팟캐스트 생성 (1단계: 생성)
**시나리오**: 새로운 장소에 대해 팟캐스트 생성

**페르소나**: QA 테스터
**우선순위**: 🟠 높음 (핵심 기능)

```
1. 팟캐스트 페이지 접근
   URL: http://localhost:3000/ko/podcast/파리-에펠탑

2. 예상 동작:
   ✓ "팟캐스트 생성하기" 버튼 표시
   ✓ 버튼 클릭 → POST 요청 시작

3. 서버 로그 확인:
   - 요청: POST /api/tts/notebooklm/generate
   - 챕터 생성 (Gemini 호출)
   - 세그먼트 파싱
   - DB 저장

4. 예상 응답:
   {
     "success": true,
     "data": {
       "episodeId": "uuid-xxx",
       "status": "script_ready",  // ← 중요!
       "chapters": [...],
       "segmentCount": N
     }
   }

5. 검증 포인트:
   - [ ] 생성 시간 < 3분
   - [ ] status = 'script_ready'
   - [ ] 모든 segment.audio_url = NULL
   - [ ] chapters 정보 완전함
   - [ ] DB에 저장됨 (SELECT FROM podcast_episodes)

6. 테스트 결과:
   [ ] 통과 / [ ] 실패 (사유: _______)
```

---

### Test Case 3: script_ready 상태 UI 표시 (1단계: 표시)
**시나리오**: 새로 생성된 팟캐스트를 페이지에서 표시

**페르소나**: 일반 사용자
**우선순위**: 🟠 높음 (사용자 경험)

```
1. Test Case 2 직후 실행

2. 예상 동작:
   ✓ 페이지가 자동으로 UI 렌더링
   ✓ 오디오플레이어 표시
   ✓ 첫 세그먼트 텍스트 표시
   ✓ 챕터 목록 표시

3. 검증 포인트:
   - [ ] UI가 블랙아웃되지 않음
   - [ ] 텍스트 콘텐츠 표시됨
   - [ ] 재생 버튼 클릭 가능
   - [ ] 챕터 선택 가능

4. 브라우저 콘솔 확인:
   - [ ] 에러 메시지 없음
   - [ ] 정상 로그만 표시

5. 테스트 결과:
   [ ] 통과 / [ ] 실패 (사유: _______)
```

---

### Test Case 4: 재생 버튼 클릭 (2단계: TTS 생성)
**시나리오**: script_ready 상태에서 재생 버튼 클릭

**페르소나**: QA 테스터
**우선순위**: 🔴 매우 높음 (핵심 미처리 로직)

```
1. Test Case 3 완료 상태에서 시작

2. 재생 버튼 클릭

3. 예상 동작:
   ✓ "오디오를 생성 중입니다..." 메시지
   ✓ 진행률 표시 시작
   ✓ POST /api/tts/notebooklm/generate-audio 호출

4. 서버 로그 확인:
   - 요청: POST /api/tts/notebooklm/generate-audio
   - 모든 세그먼트에 대해 TTS 생성
   - 오디오 파일 Supabase 업로드
   - DB 업데이트 (audio_url)

5. 예상 응답:
   {
     "success": true,
     "data": {
       "episodeId": "uuid-xxx",
       "generatedCount": 45,
       "status": "completed",
       "segments": [
         { "sequenceNumber": 1, "audioUrl": "https://..." },
         ...
       ]
     }
   }

6. 검증 포인트:
   - [ ] TTS 생성 시간 (예상: 3-5분)
   - [ ] 모든 오디오 파일 생성됨
   - [ ] 각 segment.audio_url이 유효한 URL
   - [ ] episode.status = 'completed'
   - [ ] DB 업데이트됨

7. 브라우저 동작:
   - [ ] 진행률이 100%에 도달
   - [ ] 메시지 사라짐
   - [ ] episode 상태 업데이트됨

8. 테스트 결과:
   [ ] 통과 / [ ] 실패 (사유: _______)
```

---

### Test Case 5: 순차 재생 (2단계: 재생)
**시나리오**: TTS 생성 완료 후 오디오 순차 재생

**페르소나**: 일반 사용자
**우선순위**: 🔴 매우 높음 (핵심 기능)

```
1. Test Case 4 완료 상태에서 시작

2. 현재 상태:
   - episode.status = 'completed'
   - 모든 segment.audio_url = valid_url

3. 재생 버튼 클릭 (이번엔 즉시 재생)

4. 예상 동작:
   ✓ audioRef.src = segment[0].audioUrl
   ✓ 오디오 재생 시작
   ✓ 타이머 시작 (시간 경과 표시)

5. 재생 중 검증:
   - [ ] 오디오 소리 나옴
   - [ ] 진행 시간 증가
   - [ ] 현재 텍스트 표시됨
   - [ ] 전체 진행률 표시됨

6. Segment 전환 검증:
   - [ ] Segment 1 완료
   - [ ] Segment 2 자동 로드 및 재생
   - [ ] 텍스트가 segment 2로 변경
   - [ ] 계속 반복...

7. 테스트 결과:
   [ ] 통과 / [ ] 실패 (사유: _______)
```

---

### Test Case 6: 챕터 선택 점프
**시나리오**: 재생 중 다른 챕터로 점프

**페르소나**: 일반 사용자
**우선순위**: 🟡 중간 (편의 기능)

```
1. Test Case 5 재생 중 상태에서 시작 (1~2분 재생)

2. 챕터 목록에서 "챕터 2" 선택

3. 예상 동작:
   ✓ currentSegmentIndex 변경
   ✓ 새 오디오 로드
   ✓ 자동 재생
   ✓ 텍스트 업데이트

4. 검증 포인트:
   - [ ] 즉시 챕터 2로 점프
   - [ ] 음성 재생 끊김 없음
   - [ ] 텍스트가 올바르게 변경됨
   - [ ] 전체 진행률 계산 정확함

5. 테스트 결과:
   [ ] 통과 / [ ] 실패 (사유: _______)
```

---

### Test Case 7: 재생 제어 (볼륨, 속도)
**시나리오**: 재생 중 볼륨 및 재생 속도 조절

**페르소나**: 일반 사용자
**우선순위**: 🟢 낮음 (보조 기능)

```
1. Test Case 5 재생 중 상태

2. 볼륨 조절:
   ✓ 볼륨 슬라이더 조절
   ✓ audioRef.volume 변경됨
   ✓ 음성 크기 변화

3. 재생 속도:
   ✓ 1x → 1.5x 클릭
   ✓ audioRef.playbackRate 변경됨
   ✓ 오디오 속도 변화

4. 검증 포인트:
   - [ ] 볼륨 변경 즉시 적용
   - [ ] 재생 속도 변경 즉시 적용
   - [ ] 상태 유지 (채널 변경 후에도)

5. 테스트 결과:
   [ ] 통과 / [ ] 실패 (사유: _______)
```

---

### Test Case 8: 에러 처리 (네트워크 오류)
**시나리오**: TTS 생성 중 네트워크 오류 발생

**페르소나**: QA 테스터
**우선순위**: 🟡 중간 (안정성)

```
1. Test Case 2 생성 단계에서 시작

2. 네트워크 끊김 시뮬레이션:
   DevTools → Network → "Offline" 선택

3. 재생 버튼 클릭 중 네트워크 복구

4. 예상 동작:
   ✓ 명확한 에러 메시지 표시
   ✓ 재시도 로직 또는 수동 재시도 옵션
   ✓ 상태 일관성 유지

5. 검증 포인트:
   - [ ] 사용자 친화적 에러 메시지
   - [ ] 재시도 가능
   - [ ] UI 크래시 없음

6. 테스트 결과:
   [ ] 통과 / [ ] 실패 (사유: _______)
```

---

## 🧪 테스트 실행 순서

### Phase 1: 기본 기능 검증 (완성된 팟캐스트)
```
Test 1 → [모두 통과] → Phase 2로 진행
```

### Phase 2: 생성 및 TTS 기능
```
Test 2 → Test 3 → Test 4 → [모두 통과] → Phase 3로 진행
```

### Phase 3: 재생 및 사용자 경험
```
Test 5 → Test 6 → Test 7 → [모두 통과] → Phase 4로 진행
```

### Phase 4: 안정성
```
Test 8 → [모두 통과] → 검증 완료
```

---

## 📊 테스트 결과 기록

### Test Summary

| # | 테스트 케이스 | 결과 | 소요 시간 | 비고 |
|----|-----------|------|---------|------|
| 1 | 완성된 팟캐스트 접근 | ⏳ | - | - |
| 2 | 새 팟캐스트 생성 (1단계) | ⏳ | - | - |
| 3 | script_ready UI 표시 | ⏳ | - | - |
| 4 | 재생 버튼 클릭 (TTS) | ⏳ | - | - |
| 5 | 순차 재생 | ⏳ | - | - |
| 6 | 챕터 선택 점프 | ⏳ | - | - |
| 7 | 재생 제어 | ⏳ | - | - |
| 8 | 에러 처리 | ⏳ | - | - |

---

## 🔍 체크리스트

### 테스트 전 준비
- [ ] 개발 서버 실행 (npm run dev)
- [ ] 데이터베이스 연결 확인
- [ ] Supabase 스토리지 접근 가능
- [ ] Gemini API 키 설정
- [ ] 브라우저 DevTools 열기
- [ ] 콘솔 모니터링

### 테스트 중 모니터링
- [ ] 브라우저 콘솔 (에러 메시지)
- [ ] 네트워크 탭 (API 호출)
- [ ] 서버 로그 (백엔드 처리)
- [ ] 성능 (응답 시간)

### 테스트 후 분석
- [ ] 모든 테스트 케이스 완료
- [ ] 결과 문서화
- [ ] 문제점 정리
- [ ] 해결 방안 제시

---

## 📝 테스트 주의사항

### 보안
- 실제 사용자 데이터 사용 금지
- 테스트 계정만 사용

### 성능
- TTS 생성은 시간이 소요됨 (예상 3-5분)
- 다른 작업 없이 전용 테스트 권장

### 네트워크
- 안정적인 네트워크 환경 필요
- API 호출 제한 주의 (Gemini, 오디오 생성)

---

## 🎯 최종 검증 항목

### 플로우 정규성
- [ ] 1차 플로우: 조회 → 표시 ✅
- [ ] 2차 플로우: 재생 → 순차 재생 ✅
- [ ] 데이터 경로: DB → UI → 오디오 ✅

### 사용자 경험
- [ ] 명확한 UI 피드백
- [ ] 오류 메시지 이해도
- [ ] 자연스러운 흐름

### 기술 안정성
- [ ] API 응답 구조 일관성
- [ ] 데이터 정합성
- [ ] 에러 처리 완전성

