import { NextRequest, NextResponse } from 'next/server';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { getOrCreateGoldenCoordinates } from '@/lib/ai/officialData';

// Types
interface Suggestion {
  name: string;
  location: string;
}

interface CacheItem {
  suggestions: Suggestion[];
  timestamp: number;
}

// Valid languages
const VALID_LANGUAGES = ['ko', 'en', 'ja', 'zh', 'es'] as const;
type Language = typeof VALID_LANGUAGES[number];

// 크기 제한이 있는 LRU 캐시 구현
class LRUCache<T> {
  private cache = new Map<string, T>();
  private maxSize = 100; // 최대 100개 항목

  get(key: string): T | null {
    const value = this.cache.get(key);
    if (value) {
      // LRU: 접근한 항목을 맨 뒤로 이동
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return null;
  }

  set(key: string, value: T): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      // 가장 오래된 항목 제거
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== undefined) {
        this.cache.delete(firstKey);
      }
    }
    this.cache.set(key, value);
  }

  setex(key: string, seconds: number, value: T): void {
    this.set(key, value);
    setTimeout(() => this.cache.delete(key), seconds * 1000);
  }
}

const cache = new LRUCache<any>();
const kv = {
  get: async <T>(key: string): Promise<T | null> => {
    return cache.get(key) as T | null;
  },
  set: async (key: string, value: any): Promise<'OK'> => {
    cache.set(key, value);
    return 'OK';
  },
  setex: async (key: string, seconds: number, value: any): Promise<'OK'> => {
    cache.setex(key, seconds, value);
    return 'OK';
  }
} as const;

// Rate limiting implementation
class RateLimiter {
  private requests: Map<string, {count: number, resetAt: number}>;
  private readonly windowMs: number;
  private readonly max: number;

  constructor(max: number, windowMs: number) {
    this.requests = new Map();
    this.max = max;
    this.windowMs = windowMs;
  }

  async limit(identifier: string) {
    if (process.env.NODE_ENV === 'development') {
      return { 
        success: true,
        limit: this.max,
        remaining: this.max,
        reset: 10
      };
    }

    const now = Date.now();
    const record = this.requests.get(identifier) || { count: 0, resetAt: now + this.windowMs };

    // Reset if window has passed
    if (now > record.resetAt) {
      record.count = 0;
      record.resetAt = now + this.windowMs;
    }

    // Increment request count
    record.count++;
    this.requests.set(identifier, record);

    // Calculate remaining time and requests
    const remaining = Math.max(0, this.max - record.count);
    const reset = Math.ceil((record.resetAt - now) / 1000);

    return {
      success: record.count <= this.max,
      limit: this.max,
      remaining,
      reset
    };
  }
}

// Rate limiter instance (10 requests per 10 seconds)
const rateLimiter = new RateLimiter(10, 10 * 1000);

// CORS headers
function setCorsHeaders(headers: Headers) {
  headers.set('Access-Control-Allow-Origin', '*');
  headers.set('Access-Control-Allow-Methods', 'GET, OPTIONS');
  headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  return headers;
}

// Force dynamic rendering
export const dynamic = 'force-dynamic';
// Use Node.js runtime for better compatibility
export const runtime = 'nodejs';

// Cache configuration (30 minutes in seconds)
const CACHE_DURATION = 30 * 60;


// Initialize Gemini AI with environment variable
function getGeminiClient() {
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) {
    throw new Error('GEMINI_API_KEY environment variable is not set');
  }
  return new GoogleGenerativeAI(apiKey);
}

// Generate cache key
function generateCacheKey(query: string, language: string): string {
  return `location:${language}:${query.toLowerCase().trim()}`;
}

// Sanitize input to prevent prompt injection and XSS
function sanitizeInput(input: string): string {
  if (typeof input !== 'string') return '';
  // Remove potentially dangerous characters
  return input
    .replace(/[<>\"\']/g, '') // Remove HTML tags
    .replace(/[^\w\s가-힣-.,!?]/gi, '') // Allow basic punctuation
    .trim()
    .substring(0, 200); // Limit input length
}

// Create autocomplete prompt with string matching focus
function createSearchPrompt(query: string, language: Language): string {
  const prompts = {
    ko: `사용자가 '${query}'를 입력했을 때 찾고 있을 가능성이 높은 정확한 장소명을 자동완성으로 5개 제안해줘. 
규칙:
1. 입력한 텍스트 '${query}'가 포함된 장소명을 최우선으로 제안
2. 입력 텍스트로 시작하는 장소명이 있다면 1순위로 배치
3. 정확한 장소의 전체 이름을 완성해주는 방식으로 제안
4. 검색엔진 자동완성처럼 사용자가 타이핑한 내용과 직접 매칭되는 결과 우선

각 추천은 "name"(장소의 정확한 전체 이름)과 "location"(도시와 국가) 키를 포함하는 JSON 객체여야 해. 다른 말은 하지 말고 배열만 반환해줘.

[
  {"name": "에펠탑", "location": "프랑스, 파리"},
  {"name": "에펠탑 전망대", "location": "프랑스, 파리"}
]`,
    en: `Provide 5 autocomplete suggestions for places that match the user input '${query}'.
Rules:
1. Prioritize places whose names contain the exact text '${query}'
2. Place names that start with '${query}' should be ranked first
3. Complete the place names that the user is likely typing
4. Work like search engine autocomplete - match what user is actually typing

Each suggestion must be a JSON object with "name" (exact full place name) and "location" (city and country) keys. Return only the array.

[
  {"name": "Eiffel Tower", "location": "Paris, France"},
  {"name": "Eiffel Tower Observatory", "location": "Paris, France"}
]`,
    ja: `ユーザー入力「${query}」に関連する旅行の推薦を5件生成してください。各推薦は必ず「name」（場所のフルネーム）と「location」（都市や国などの簡単な位置）キーを含むJSONオブジェクトでなければなりません。他の言葉は一切言わず、これらのオブジェクトの配列のみを返してください。

[
  {"name": "ノートルダム大聖堂", "location": "フランス、パリ"},
  {"name": "ストラスブール大聖堂", "location": "フランス、スト라スブール"}
]`,
    zh: `根据用户输入"${query}"生成5个旅游推荐。每个推荐必须是包含"name"（地点的全名）和"location"（如城市和国家的简单位置）键的JSON对象。不要说任何其他话，只返回这些对象的数组。

[
  {"name": "巴黎圣母院", "location": "法国, 巴黎"},
  {"name": "斯特拉斯堡主教座堂", "location": "法国, 斯特拉斯堡"}
]`,
    es: `Genera 5 recomendaciones de viaje relacionadas con la entrada del usuario '${query}'. Cada recomendación debe ser un objeto JSON con las claves "name" (nombre completo del lugar) y "location" (ubicación simple como ciudad y país). No digas nada más, solo devuelve un array de estos objetos.

[
  {"name": "Catedral de Notre Dame", "location": "París, Francia"},
  {"name": "Catedral de Estrasburgo", "location": "Estrasburgo, Francia"}
]`
  };
  return prompts[language] || prompts.ko;
}

// Handle OPTIONS request (CORS preflight)
export async function OPTIONS() {
  const headers = new Headers();
  setCorsHeaders(headers);
  headers.set('Allow', 'GET, OPTIONS');
  
  return new Response(null, {
    status: 204,
    headers,
  });
}

export async function GET(request: NextRequest) {
  // Set CORS headers
  const headers = new Headers();
  setCorsHeaders(headers);
  
  // Handle OPTIONS request
  if (request.method === 'OPTIONS') {
    return new Response(null, { status: 204, headers });
  }
  
  try {
    // Apply rate limiting
    if (process.env.NODE_ENV !== 'development') {
      const ip = request.headers.get('x-forwarded-for') || 'anonymous';
      const limitResult = await rateLimiter.limit(ip);
      
      if (!limitResult.success) {
        headers.set('Content-Type', 'application/json');
        headers.set('Retry-After', limitResult.reset?.toString() || '10');
        headers.set('X-RateLimit-Limit', limitResult.limit?.toString() || '10');
        headers.set('X-RateLimit-Remaining', limitResult.remaining?.toString() || '0');
        headers.set('X-RateLimit-Reset', limitResult.reset?.toString() || '10');
        return new Response(
          JSON.stringify({ 
            success: false,
            error: 'Too many requests. Please try again later.',
            ...(process.env.NODE_ENV !== 'production' && {
              limit: limitResult.limit,
              remaining: limitResult.remaining,
              reset: limitResult.reset
            })
          }),
          { 
            status: 429, 
            headers,
          }
        );
      }
    }

    // Get query parameters with validation
    const { searchParams } = new URL(request.url);
    const query = searchParams.get('q');
    const language = (searchParams.get('lang') || 'ko') as Language;

    // Validate input
    if (!query || typeof query !== 'string') {
      return new Response(
        JSON.stringify({ 
          success: false, 
          error: '유효한 검색어를 입력해주세요' 
        }),
        { 
          status: 400, 
          headers: { 'Content-Type': 'application/json' } 
        }
      );
    }

    // Validate query length
    if (query.length < 2 || query.length > 200) {
      return new Response(
        JSON.stringify({ 
          success: false, 
          error: '검색어는 2자 이상 200자 이하로 입력해주세요' 
        }),
        { 
          status: 400, 
          headers: { 'Content-Type': 'application/json' } 
        }
      );
    }

    // Sanitize and validate language
    const lang = VALID_LANGUAGES.includes(language) ? language : 'ko';
    
    // Check cache
    const cacheKey = generateCacheKey(query, lang);
    const cached = await kv.get<CacheItem>(cacheKey);
    
    if (cached && (Date.now() - cached.timestamp < CACHE_DURATION * 1000)) {
      return NextResponse.json(
        { success: true, data: cached.suggestions, cached: true },
        { headers }
      );
    }

    // Generate response using Gemini AI
    try {
      const gemini = getGeminiClient();
      const model = gemini.getGenerativeModel({ 
        model: 'gemini-1.5-flash',
        generationConfig: {
          temperature: 0.3,
          maxOutputTokens: 2048,
        }
      });
      
      const prompt = createSearchPrompt(sanitizeInput(query), lang);
      
      // Set timeout for API call (30 seconds)
      const TIMEOUT_MS = 30000; // 30 seconds
      const startTime = Date.now();
      
      // Create a promise that will reject after the timeout
      const createTimeoutPromise = (ms: number) => {
        return new Promise<never>((_, reject) => {
          const timer = setTimeout(() => {
            clearTimeout(timer);
            reject(new Error('AI 응답 시간이 초과되었습니다. 잠시 후 다시 시도해주세요.'));
          }, ms);
        });
      };
      
      let result, response, text;
      
      try {
        // Make the API call
        const generatePromise = model.generateContent(prompt);
        
        // Race between the API call and the timeout
        result = await Promise.race([
          generatePromise,
          createTimeoutPromise(TIMEOUT_MS)
        ]) as any;
        
        response = await result.response;
        text = await response.text();
      } catch (apiError) {
        console.error('API 처리 중 오류 발생:', apiError);
        throw apiError;
      }
      
      
      // Parse response (assuming it's a JSON string)
      let suggestions: Suggestion[] = [];
      
      try {
        // AI가 마크다운 코드 블록을 포함할 수 있으므로, JSON만 추출
        const jsonMatch = text.match(/```(?:json)?\s*([\s\S]*?)\s*```/s);
        const jsonString = jsonMatch ? jsonMatch[1].trim() : text.trim();
        
        const parsed = JSON.parse(jsonString);
        
        // 프롬프트가 배열을 반환하도록 지시했으므로, 배열인지 확인
        if (Array.isArray(parsed)) {
          suggestions = parsed.filter(item => item.name && item.location);
        }
        
        // Update cache
        const cacheItem: CacheItem = {
          suggestions,
          timestamp: Date.now()
        };
        await kv.setex(cacheKey, CACHE_DURATION, cacheItem);

        return NextResponse.json(
          { 
            success: true, 
            data: suggestions, 
            cached: false 
          },
          { headers }
        );
        
      } catch (parseError) {
        console.error('❌ AI 응답 처리 실패:', parseError);
        console.error('❌ 오류 발생한 응답 내용:', text);
        return NextResponse.json(
          { 
            success: false, 
            error: 'AI 응답 처리에 실패했습니다',
            details: parseError instanceof Error ? parseError.message : '알 수 없는 오류',
            ...(process.env.NODE_ENV === 'development' && {
              responsePreview: text ? (text.length > 200 ? text.substring(0, 200) + '...' : text) : 'No response content'
            })
          },
          { status: 500, headers }
        );
      }
      
    } catch (error) {
      console.error('❌ 요청 처리 중 오류 발생:', error);
      
      // Handle different error types
      let errorMessage = '서버 내부 오류가 발생했습니다';
      let statusCode = 500;
      
      if (error instanceof Error) {
        const errMsg = error.message;
        if (errMsg.includes('timeout') || errMsg.includes('time out')) {
          errorMessage = '요청 시간이 초과되었습니다. 잠시 후 다시 시도해주세요.';
          statusCode = 504; // Gateway Timeout
        } else if (errMsg.includes('API key') || errMsg.includes('인증')) {
          errorMessage = '인증 오류가 발생했습니다. 관리자에게 문의해주세요.';
          statusCode = 401; // Unauthorized
        }
      }
      
      return NextResponse.json(
        { 
          success: false, 
          error: errorMessage,
          ...(process.env.NODE_ENV === 'development' && {
            message: error instanceof Error ? error.message : String(error),
            stack: process.env.NODE_ENV === 'development' && error instanceof Error ? error.stack : undefined
          })
        },
        { 
          status: statusCode, 
          headers: { 
            ...Object.fromEntries(headers.entries()),
            'Content-Type': 'application/json',
            'Cache-Control': 'no-store, max-age=0'
          } 
        }
      );
    }
  } catch (error) {
    console.error('❌ 처리되지 않은 오류 발생:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: '처리 중 예기치 않은 오류가 발생했습니다',
        ...(process.env.NODE_ENV === 'development' && {
          message: error instanceof Error ? error.message : String(error)
        })
      },
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
}

// === 골든레코드 기반 좌표 자동화 엔드포인트 ===
export async function POST(req) {
  try {
    const { locationName, language } = await req.json();
    if (!locationName || !language) {
      return new Response(JSON.stringify({ success: false, error: '필수 파라미터 누락' }), { status: 400 });
    }
    const coordinates = await getOrCreateGoldenCoordinates(locationName, language);
    return new Response(JSON.stringify({ success: true, coordinates }), { status: 200 });
  } catch (e) {
    const err = e instanceof Error ? e : new Error(String(e));
    return new Response(JSON.stringify({ success: false, error: err.message }), { status: 500 });
  }
}
